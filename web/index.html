<html>
<!--
	HOW IT WORKS
	
	1. A number of classes with names starting with sbitx- are defined these are
	used to implment sbitx specific handlers for events, etc.

	2. A single websocket is used for efficient communication with the sbitx process
	The websocket is used to transmit text messages for UI interactions and a binary
	format for raw audio samples. 
	2.1 The audio samples are enabled only for remote login. We do this by detecting if
	the sbitx url is localhost or not.
	2.2 All commands are implemented as fields of UI in sbitx. Read the C source to 
	understand those.

	SEMANTIC STRUCTURE		
  
  The top bar has frequency, volume, mode and icons to restore the web ui,
	enable/disable the on-screen keyboard, etc.  

	Each mode like ssb, ft8, etc has its one div that is enabled and others are all disabled.
	
	MAKING YOUR OWN SKINS
	we can use different skins by replacing/editing the index.html and the style.css
	in /home/pi/sbitx/web directory on the sbitx. 	

	CREDITS:
	The wonderful knob is from https://github.com/aterrien/jQuery-Knob
-->
	<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>sBitx</title>
    <script src="jquery.min.js"></script>
    <script src="jquery.knob.min.js"></script>
    <script src="pcm-player.js"></script> 
		<link rel="stylesheet" href="style.css">
  </head>
  <body>
	<input type="hidden" id="FREQ" value="7040000"/>
	<input type="hidden" id="VFOA" value="7040000"/>
	<input type="hidden" id="VFOB" value="7040000"/>
	<input type="hidden" id="POWER" value="0"/>
	<input type="hidden" id="REF" value="1"/>
	<input type="hidden" id="HIGH" value="2200"/>
	<input type="hidden" id="LOW" value="300"/>
	<input type="hidden" id="STATUS" value="---" />
	<input type="hidden" id="REC" value="OFF" /> 
	<input type="hidden" id="RIT_DELTA" name="RIT_DELTA" value="" /> 
	<input type="hidden" id="VFO" value="A" />
  <div id="sdr_page">
	<div id="maincontrols">
		<div class="sbitxv3-control">
			<div class="sbitxv3-label">MODE</div>
			<select class="sbitxv3-selection sbitx-selection" id="MODE">
				<option value="USB">USB</option>
				<option value="LSB">LSB</option>
				<option value="CW">CW</option>
				<option value="CWR">CWR</option>
				<option value="FT8">FT8</option>
				<option value="PSK31">PSK31</option>
				<option value="RTTY">RTTY</option>
				<option value="DIGITAL">DIGITAL</option> 
				<option value="2TONE">2TONE</option>
			</select>
		</div><div class="sbitxv3-control" id="dial">
    	<span id="current_freq">A:00.000.000</span> 
			<span id="other_freq">B: 00.000.000</span>
		</div><!-- funny html that breaks the line inside the button tag to 
		prevent spaces between the elements 
		--><button class="sbitxv3-btn" id="80M" type="submit">80M</button
			><button class="sbitxv3-btn" id="40M" type="submit">40M</button
			><button class="sbitxv3-btn" id="30M" type="submit">30M</button
			><button class="sbitxv3-btn" id="20M" type="submit">20M</button
			><button class="sbitxv3-btn" id="17M" type="submit">17M</button
			><button class="sbitxv3-btn" id="15M" type="submit">15M</button
			><button class="sbitxv3-btn" id="12M" type="submit">12M</button
			><button class="sbitxv3-btn" id="10M" type="submit">10M</button
		><div class="sbitxv3-control rx-control">
			<div class="sbitxv3-label">AGC </div>
			<select class="sbitxv3-selection sbitx-selection" id="AGC">
				<option value="FAST">FAST</option>
				<option value="MED">MED</option>
				<option value="SLOW">SLOW</option>
				<option value="OFF">OFF</option>
			</select>
		</div><div class="linear rx-control" id="linear_BW">
    	<div class="linear-label">BW</div>
    	<input type="number" id="BW" min="0" max="100" class="linear-value" />
     	<div class="linear-dropdown">
      	<input type="range" class="linear-slider"
        	id="slider_BW" max="5000" min="50" step="50" value="13" />
			</div>
		</div><div class="linear rx-control" id="linear_IF">
    	<div class="linear-label">IF</div>
    	<input type="number" id="IF" min="0" max="100" class="linear-value" />
     	<div class="linear-dropdown">
      	<input type="range" class="linear-slider"
        	id="slider_IF" max="100" min="0" step="1" value="13" />
			</div>
    </div><div class="linear rx-control" id="linear_AUDIO">
    	<div class="linear-label">AUDIO</div>
    	<input type="number" id="AUDIO" min="0" max="100" class="linear-value" />
     	<div class="linear-dropdown">
      	<input type="range" class="linear-slider"
        	id="slider_AUDIO" max="100" min="0" step="1" value="13" />
			</div>
    </div><br/>
		<div class="linear" id="linear_DRIVE">
    	<div class="linear-label">DRIVE</div>
    	<input type="number" id="DRIVE" min="1" max="100" class="linear-value" />
     	<div class="linear-dropdown">
      	<input type="range" class="linear-slider"
        	id="slider_DRIVE" max="100" min="1" step="1" value="13" />
			</div>
		</div><div class="sbitxv3-control">	
			<div class="sbitxv3-label">STEP</div>
			<select id="STEP" class="sbitx-selection sbitxv3-selection">
				<option value="10H">10H</option>
				<option value="100H">100H</option>
				<option value="1K">1K</option>
				<option value="10K">10K</option>
				<option value="100K">100K</option>
			</select>
		</div><div class="sbitxv3-control">
			<div class="sbitxv3-label">VFO</div>
			<select class="sbitxv3-selection sbitx-selection" id="VFO">
				<option value="A">A</option>
				<option value="B">B</option>
			</select>
		</div><div class="sbitxv3-control">
			<div class="sbitxv3-label">SPLIT</div>
			<select class="sbitxv3-selection sbitx-selection" id="SPLIT">
				<option value="OFF">OFF</option>
				<option value="ON">ON</option>
			</select>
		</div><div class="sbitxv3-control">
			<div class="sbitxv3-label">RIT</div>
			<select class="sbitxv3-selection sbitx-selection" id="RIT">
				<option value="OFF">OFF</option>
				<option value="ON">ON</option>
			</select>
		</div><button class="sbitxv3-btn" id="qrz" tabindex=-1>?</button
		><input type="text" class="logger-input sbitx-text-input sbitx-text-field" 
			id="CALL" placeholder="Call" size="6" 
		><input type="text" class="logger-input sbitx-text-input sbitx-text-field" 
			id="SENT" placeholder="Sent" size="3" 
		/><input type="text" class="logger-input sbitx-text-input sbitx-text-field" 
			id="RECV" placeholder="Rcv" size="3" 
		/><input type="text" class="logger-input sbitx-text-input sbitx-text-field" 
			id="EXCH" placeholder="Exch" size="2" 
		/><input type="text" class="logger-input sbitx-text-input sbitx-text-field" 
			id="NR" placeholder="Nr" size="2" 
		/><button class="sbitxv3-btn" id="logger-log">OK</button
		><button class="sbitxv3-btn" id="wipe">WIPE</button
		><button class="sbitxv3-btn" id="logbook-open">SAVE</button
		><div class="sbitxv3-control">
			<div class="sbitxv3-label">SPAN</div>
			<select class="sbitxv3-selection sbitx-selection" id="SPAN">
				<option value="25K">25K</option>
				<option value="10K">10K</option>
				<option value="6K">6K</option>
				<option value="2.5K">2.5K</option>
			</select>
		</div>
	</div><!-- end of maincontrols -->
		<span id="restore-btn" onclick="toggle_fullscreen();"> &#X21F3; </span>
	<div id="sidebar"> 
		<div class="menu-item" id="tuning_knob">
			<input id="big_tuning_knob"
				class="knob" data-width="190" 
				data-height="190" data-displayInput=false 
				data-cursor=true data-fgColor="#222222" data-thickness=.3 
				data-step=1 data-max=360 value="0">
		</div>
		</div> <!-- end of sidebar -->	
		<div id="main">
<!-- settings panel -->
	<div id="settings_panel" class="sbitx-panel">
		<span class="sbitx-panel-title">
			<button class="sbitx-btn-back" data-for="panel_bar">&#x2716; Close</button>  
		</span>

		<div class="settings-element">
			<span class="settings-label">Passkey:</span><input id="PASSKEY" 
					class="settings_input sbitx-text-input" type="text" size="6" />
		</div>

		<div class="settings-element">
			<span class="settings-label">My Callsign:</span><input id="MYCALLSIGN" 
					class="settings_input sbitx-text-input" type="text" size="6" />
		</div>

		<div class="settings-element">
			<span class="settings-label">My Grid:</span><input id="MYGRID" 
					class="settings_input sbitx-text-input" type="text" size="6" />
		</div>
		<div class="settings-element">
			<span class="settings-label">Telnet Server:</span> 
			<input type="text" class="settings_input sbitx-text-input" size="17"
				id="TELNETURL" />
			(Like : dxc.nc7j.com:7373)
		</div>
		<div class="settings-element">
			<span class="settings-label"></span>
			<button id="settings_save" class="logger-button">Update</button>		
		</div>
	</div><!-- end of help text -->
  		<div id="login_panel">
				<div class="help_text">
				<h1>sBitx v3</h1>
					<p>The sBitx is an open-source, hackable, next generation radio.</p>
 			 			<p>Enter passkey to access your sbitx.</p> 
						<div id="login_error"></div>
  					<input type="text" class="sbitx-text-input" id="passkey" 
						name="passkey" autocomplete="off" placeholder="passkey"/>
  					<button class="logger-button" id="start_login" >Start</button>
					<p>New user? Try 123 as the passkey. Change it when prompted.</p>	
					<p>Released under General Public Licens v3.0.<br/>
					(c) Ashhar Farhan, 2023
					</p>
				</div>
  		</div><!-- end of login -->
			<!-- it streams automatically, anyway 
			<div id="extra-controls">
				<button id="streamaudio" type="submit" onclick="audio_start();">Stream Audio</button> 
			</div>
			-->
	<!-- logbook -->
	<div id="logbook_panel" class="sbitx-panel">
			<input class="logger-input sbitx-text-input sbitx-text-field"
				id="logbook-search" type="text" size="6" placeholder="Search"/>
			<button class="sbitxv3-btn longer-control" id="btn-logbook-load">More</button> 
			<button class="sbitxv3-btn longer-control" id="btn-logbook-close">Close</button> 
		<table id="logbook_table">
			<thead><tr>
				<th class="logbook-serial">#</th>
				<th class="logbook-datestamp">Date-Time</th>
				<th class="logbook-freq">Freq</th>
				<th class="logbook-mode">Mode</th>
				<th class="logbook-call">Call</th>
				<th class="logbook-sent">Sent</th>
				<th class="logbook-recv">Recv</th>
			</tr></thead>
			<tbody>
			</tbody>
		</table>
	</div>
<!--   panadapter, xxxx_open functions will resize this as needed -->
<!-- pan adapter and waterfall -->
		<div id="pan_adapter">
			<div id="console">Hello</div>
			<div id="tx_meters">
				<div class="menu-item">
					<span class="slider-label">Watts</span>
					<meter id="POWER_meter" max="500" min="0" value="0"></meter>
					<span id="POWER_reading"></span> 
				</div>
				<div class="menu-item">
					<span class="slider-label">SWR</span> 
					<meter id="REF_meter" max="1000" min="0" value="0"></meter>
					<span id="REF_reading"/></span>
				</div>
			</div><!-- end of tx_meters --> 
<!-- recorder panel -->
	<div id="recorder_panel" class="sbitx-panel mode-panel">
			<span class="sbitx-panel-title">
				<button class="sbitx-btn-back" data-for="panel_bar">&#x2716; Close</button>  
			</span>
			<div class="menu_item">
				<button class="logger-button" id="record_start">REC</button>
				<button class="logger-button" id="record_stop">STOP</button>
				<span id="record_duration">00:00</span>
			</div>
	</div>	
			<div id="spectrum-wrap">
				<div width="100%"><canvas id="spectrum" width="600" height ="80"></canvas></div>
			</div><!-- end of spectrum-wrap -->
			<div width="100%"><canvas id="waterfall" width="600" height="80"></canvas></div>
		</div>
<!-- end of panadapter -->
<!- wsjtx specific controls -->
		<div id="FT8_ui" class="sbitx-panel mode-panel">
			<div id="wsjtx-activity" class="sbitx-list-container" >
				Band Activity
				<ol size="10" class="sbitx-list-box">
				</ol>
			</div>
			<div id="wsjtx-rx" class="sbitx-list-container" >
				RX Frequency
				<ol size="10" class="sbitx-list-box">
				</ol>
			</div>

			<div id="FT8_controls">
				<div class="sbitxv3-control">
					<div class="sbitxv3-label">AUTO</div>
					<select class="sbitxv3-selection sbitx-selection" id="FT8_AUTO">
						<option value="ON">ON</option>
						<option value="OFF">OFF</option>
					</select>
				</div>
				<div class="sbitxv3-control">
					<div class="sbitxv3-label">TX1ST</div>
					<select class="sbitxv3-selection sbitx-selection" id="FT8_TX1ST">
						<option value="ON">ON</option>
						<option value="OFF">OFF</option>
					</select>
				</div><div class="linear" id="linear_TX_PITCH">
    		<div class="linear-label">TX TONE</div>
    			<input type="number" id="TX_PITCH" min="10" max="4000" class="linear-value" />
     		<div class="linear-dropdown">
      			<input type="range" class="linear-slider"
        			id="slider_TX_PITCH" max="4000" min="10" step="10" value="1900" />
					</div>
				</div><div class="linear" id="linear_FT8_REPEAT">
    			<div class="linear-label">REPEAT</div>
    			<input type="number" id="FT8_REPEAT" min="1" max="10" class="linear-value" />
     		<div class="linear-dropdown">
      		<input type="range" class="linear-slider"
        		id="slider_FT8_REPEAT" max="10" min="1" step="1" value="3" />
				</div>
			</div><!-- end of FT8_controls -->
		</div>
	</div>
<!- cw pane -->
		<div id="CW_ui" class="sbitx-panel mode-panel">
			<div id="data_window" tabindex="0">
				<span id="text_done"></span>
				<span id="text_pending"></span>
			</div>
			<div id="cw_settings">
				<div class="linear" id="linear_WPM">
    			<div class="linear-label">WPM</div>
    			<input type="number" id="WPM" min="0" max="100" class="linear-value" />
     			<div class="linear-dropdown">
      			<input type="range" class="linear-slider"
        			id="slider_WPM" max="40" min="5" step="1" value="13" />
					</div>
				</div><div class="linear" id="linear_PITCH">
    			<div class="linear-label">PITCH</div>
    			<input type="number" id="PITCH" min="0" max="100" class="linear-value" />
     			<div class="linear-dropdown">
      			<input type="range" class="linear-slider"
        			id="slider_PITCH" max="3000" min="50" step="10" value="600" />
					</div>
				</div><div class="linear" id="linear_CW_DELAY">
    			<div class="linear-label">DELAY</div>
    			<input type="number" id="CW_DELAY" min="50" max="1000" class="linear-value" />
     			<div class="linear-dropdown">
      			<input type="range" class="linear-slider"
        			id="slider_PITCH" max="1000" min="50" step="50" value="600" />
					</div>
				</div><div class="linear" id="linear_SIDETONE">
    			<div class="linear-label">TX VOL</div>
    			<input type="number" id="SIDETONE" min="0" max="100" class="linear-value" />
     			<div class="linear-dropdown">
      			<input type="range" class="linear-slider"
        			id="slider_SIDETONE" max="100" min="0" step="5" value="600" />
					</div>
				</div><div class="sbitx-control longer-control">
					<div class="sbitxv3-label">INPUT</div>
						<select class="sbitxv3-selection sbitx-selection" id="CW_INPUT">
							<option value="IAMBIC">IAMBIC</option>
							<option value="IAMBICB">IAMBIC-B</option>
							<option value="STRAIGHT">STRAIGHT</option>
					</select>
				</div>
			</div>
			<span id="data_chat">
					<button  id="data_chat_tx">TX</button> 
					<button id="data_chat_rx">RX</button> 
			</span>
		</div>
<!-- ssb/2tone pane -->
	<div id="Voice_ui" class="sbitx-panel mode-panel">
    <div class="linear" id="linear_MIC">
    	<div class="linear-label">MIC</div>
    	<input type="number" id="MIC" min="0" max="100" class="linear-value" />
     	<div class="linear-dropdown">
      	<input type="range" class="linear-slider"
        	id="slider_MIC" max="100" min="0" step="1" value="13" />
			</div>
    </div>
		<button id="ptt_tx">TX</button>
		<button id="ptt_rx">RX</button>
	</div>	
<!-- console panel -->
		<div id ="console_panel" class="sbitx-panel">
			Terminal	
			<span class="sbitx-panel-title">
				<button class="sbitx-btn-back" data-for="panel_bar">&#x2716; Close</button>  
			</span>
			<div id="console_window">
			</div>
			<div id="command_bar">
				<input type="text" class="sbitx-text-input"  id="text_in" />
			</div>
		</div>

<!-- telnet panel -->
		<div id ="telnet_panel" class="sbitx-panel">
			<span class="sbitx-panel-title">
				<button class="sbitx-btn-back" data-for="panel_bar">&#x2716; Close</button>  
			</span>
			Telnet 
				<button id="telnet" class="logger-button sbitx-btn">Start</button>	 
				<button id="tclose" class="logger-button sbitx-btn">Stop</button> 
			<div id="telnet_window">
			</div>
			<div id="telnet_command_bar">
				<input type="text" class="sbitx-text-input"  id="telnet_in" />
			</div>
		</div>


	</div><!-- end of main used to limit overlapping of sidebar -->   
<!-- the keyboard, comes at the bottom of them all -->
</div> <!-- end of sdr_page (vs login page, etc)--> 
	<div id="keybd-container">
		<div id="more_keys">
		<div class="Sbitxv3-control">
			<div class="sbitxv3-label">MACRO</div>
			<select class="sbitxv3-selection sbitx-selection" id="MACRO">
			</select>
		</div>
		<button class="sbitxv3-btn" id="esc">ESC</button
		><button class="sbitxv3-btn macro-btn" id="F1">F1</button
		><button class="sbitxv3-btn macro-btn" id="F2">F2</button
		><button class="sbitxv3-btn macro-btn" id="F3">F3</button
		><button class="sbitxv3-btn macro-btn" id="F4">F4</button
		><button class="sbitxv3-btn macro-btn" id="F5">F5</button
		><button class="sbitxv3-btn macro-btn" id="F6">F6</button
		><button class="sbitxv3-btn macro-btn" id="F7">F7</button
		><button class="sbitxv3-btn macro-btn" id="F8">F8</button
		><button class="sbitxv3-btn macro-btn" id="F9">F9</button
		><button class="sbitxv3-btn macro-btn" id="F10">F10</button>
		<button class="sbitxv3-btn" id="console-open">CMD</button
		><button class="sbitxv3-btn" id="telnet-open">TEL</button
		><button class="sbitxv3-btn" id="recorder-open">REC</button
		><button class="sbitxv3-btn" id="settings-open">SET</button>
		<input type="text" class="sbitx-text-input sbitx-text-field" 
			id="TEXT" placeholder="TEXT\CMD" size="20" />
		</div><!-- end of more_keys -->
		<table id="keybd" class="sbitx-keystroke" width="100%">
			<tr>
			<td>Q</td><td>W</td><td>E</td><td>R</td><td>T</td><td>Y</td><td>U</td>
			<td>I</td><td>O</td><td>P</td><td>@</td><td>1</td><td>2</td><td>3</td><td colspan="2">DEL</td>
			</tr>
			<tr>
			<td>CMD</td><td>A</td><td>S</td><td>D</td><td>F</td><td>G</td><td>H</td>
			<td>J</td><td>K</td><td>L</td><td>/</td><td>4</td><td>5</td><td>6</td><td colspan="2">Enter</td>
			</tr>
			<tr>
			<td>SPACE</td><td>Z</td><td>X</td><td>C</td><td>V</td><td>B</td><td>N</td>
			<td>M</td><td>,</td><td>.</td><td>?</td><td>7</td><td>8</td><td>9</td><td>0</td><td>[x]</td>
			</tr>
		</table>
	</div> <!-- end of on screen keyboard -->
	<div class="menu-item">
		<a href="https://www.hamqsl.com/solar.html" 
			title="Click to add Solar-Terrestrial Data to your website!">
			<img src="https://www.hamqsl.com/solarbc.php">
		</a>
	</div>
<!- tx panel -->
</body>

<script>

var in_tx = false;
var parser = null;
var qrz_window = null;
var session_id = "nullsession";
var macros_file = "";
var spots = null;
var logbook_bottom_row_id = -1;
var logbook_top_row_id= 0;

/* a few helper functions */
function el(element_id){
	return document.getElementById(element_id);
}

function log(str){
	console.log(str);
}

function isdigit(str){
	if (isNaN(str[0]))
		return false;
	else
		return true;
}

/* socket handlers */
var socket = null;

function on_open(event){
	log("socket is connected");
	websocket_send("login="+el("passkey").value);
}

function on_close(event){
	log("socket was closed by the radio");
	end_login("Connection lost");
}

function on_message(event){
	response_handler(event.data);
}

function websocket_send(str){
	//adds the session id 
	if (socket == null)
		return;

	if(str.substring(0,3) == "key")
		log("got it");
	var request = session_id + "\n" + str;
//	log("ws tx:[" + request + "]");
	socket.send(request);
}

function on_error(event){
  log("socket communication error, resetting now");
	if (socket != null)
  	socket.close();
  socket = null;
	session_id = "nullsession";
	log("on_error: session_id set to " + session_id);
  show_login();
}

/* login handler */

function end_login(reason){
	socket = null;
	session_id = "nullsession";
	log("end_login called:"+ reason);
	$("#login_error").innerHTML = reason;
	show_login();
}

function go_fullscreen(){
	var elem =	document.documentElement;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
}

function do_login() {
	log("requesting full screen");
	if (document.location.hostname == "127.0.0.1")
		go_fullscreen();
//	document.documentElement.requestFullscreen();
	log("done full screen");
	if (socket != null)
		socket.close();
	log("reset the socket, if any");
	if(el("passkey").value.length < 3 && document.location.hostname != "127.0.0.1"){
		alert("Enter the passkey (three characters or more)");
		return false;
	}
	log("creating a new socket, if any");
	socket = new WebSocket("ws://" + location.host + "/websocket");
	log("created the new socket");
	socket.onopen = on_open;
	socket.onmessage = on_message;
	socket.onclose = on_close;
	socket.onerror = on_error;
	if (document.location.hostname != "127.0.0.1")
		audio_start();
}

// ui panel switchers
function show_login(){
	$("#login_panel").show();
	$(".sbitx-panel").hide();
	$("#pan_adapter").hide();
	$("#cmd").hide();
	$("#sidebar").hide();
	$("#more_keys").hide();
	$("#maincontrols").hide();
	if (document.location.hostname == "127.0.0.1")
		show_keyboard();
	
	//this is a hack to make the onscreen keyboard
	//work with the passkey
	text_focus = el("passkey");
	el("passkey").value = "";
	$("#passkey").focus();
}

function show_main(){
	var dial = el("sidebar");
	var main = el("main");
	if (document.location.hostname == "127.0.0.1"){
		main.style.marginLeft = 0;
		dial.style.display = "none";	
	}
	else {
		main.style.marginLeft = 200;
		dial.style.display = "block";	
	}
	$("#pan_adapter").show();
	$("#login_panel").hide();
	$("#more_keys").show();
	$("#maincontrols").show();
	websocket_send("logbook=-1");
	websocket_send("macros_list=macros_list");
}

function toggle_fullscreen(){
	if (document.fullscreenElement != null){
		if (document.exitFullscreen)
			document.exitFullscreen();
		else
			document.documentElement.exitFullscreen();
	}
	else 
		document.documentElement.requestFullscreen();
}

function freq2str(freq){
	return freq.substring(0,freq.length - 6) + '.' 
			+ freq.substring(freq.length-6, freq.length - 3) 
			+ '.' + freq.substring(freq.length-3);		
}


function draw_meters(event){
	var power = parseInt(el("POWER").value);
	var ref = parseInt(el("REF").value);

	if (power == 0)
		ref = 10;

	el("POWER_meter").value = power;
	el("POWER_reading").innerHTML = (power/10).toFixed(0);

	el("REF_meter").value = ref;
	el("REF_reading").innerHTML = (ref/10).toFixed(1);
}


function update_freq(freq){
	websocket_send("freq "+freq);
}

/* All tuning related functions including the soft-kob, drawing the dial etc. */


function vfo_set(event){
	var vfo_a = el("VFOA").value;
	var vfo_b = el("VFOB").value;
	var vfo   = el("VFO").value; //which one is used?
	var f = el("FREQ").value;

	var btn_id = event.currentTarget.id;

	if (btn_id == 'vfo_reset'){
		if (vfo == 'A')
			vfo_b = vfo_a;
		else
			vfo_a = vfo_b;
	}
	else if (btn_id == "vfo_swap"){
		var swap = vfo_a;
		vfo_a = vfo_b;
		vfo_b = swap;
	}
	websocket_send("VFOB " + vfo_b);
	websocket_send("VFOA " + vfo_a);
	el("VFOA").value = vfo_a;
	el("VFOB").value = vfo_b;
	if (vfo == 'A')
		websocket_send("FREQ " + vfo_a);
	else
		websocket_send("FREQ " + vfo_b);
	draw_dial();
}

//draw_dial is called after setting FREQ to the current freq
function draw_dial(){
	var freq = el("FREQ").value;
	var split = el("SPLIT").value;
	var rit   = el("RIT").value;
	var vfo_a = el("VFOA").value;
	var vfo_b = el("VFOB").value;
	var vfo   = el("VFO").value; //which one is used?
	var rit_delta = el("RIT_DELTA").value;

	if (rit == "ON"){
		if (in_tx == 1){
			el("current_freq").innerHTML = "TX&nbsp;" + freq2str(freq);
			el("other_freq").innerHTML = 
				"RX&nbsp;" + freq2str((parseInt(freq)+ parseInt(rit_delta)).toString()); 
		}
		else {
			el("current_freq").innerHTML = 
				"RX&nbsp;" + freq2str((parseInt(freq) + parseInt(rit_delta)).toString());
			el("other_freq").innerHTML = "TX&nbsp;" + freq2str(freq); 
		}
	}
	else if (split == "ON") {
		if (in_tx == 0){
			el("current_freq").innerHTML =  "RX&nbsp;" + freq2str(freq);
			el("other_freq").innerHTML =  "TX&nbsp;" + freq2str(vfo_b);
		}
		else {
			el("current_freq").innerHTML = "TX&nbsp;" + freq2str(vfo_b);
			el("other_freq").innerHTML = "RX&nbsp;" + freq2str(freq);
			
		}
	}
	else if (vfo == 'A'){
		if (!in_tx){
			el("current_freq").innerHTML = "A&nbsp;" + freq2str(freq);
			el("other_freq").innerHTML =  "B&nbsp;" + freq2str(vfo_b);
		} else {
			el("current_freq").innerHTML = "TX&nbsp;" + freq2str(vfo_a);
			el("other_freq").innerHTML = "B&nbsp;" + freq2str(freq);
		}
	}
	else if (vfo == 'B'){
		if (!in_tx){
			el("current_freq").innerHTML = "B&nbsp;" + freq2str(freq);
			el("other_freq").innerHTML = "A&nbsp;" + freq2str(vfo_a);
		} else {
			el("current_freq").innerHTML =  "TX&nbsp;" + freq2str(freq);
			el("other_freq").innerHTML = "A&nbsp;" + freq2str(vfo_a);
		}
	}	
}



/*
	TUNING PANEL
	This handles all frequency changing related functionality
	like RIT, SPLIT, etc.
*/

let tuning_position_last = 0;
var knob_resolution = 6;

function tuning_knob_handler(position_now){
	//avoid small movements
	if (Math.abs(position_now - tuning_position_last) < knob_resolution)
		return;

	//calculate the relative movement of the dial knob
	var delta = 0;
	//we reduce the granulity of the step 
	if (position_now < 90 && tuning_position_last > 270)
		delta = position_now + 360.0 - tuning_position_last;
	else if (position_now > 270 && tuning_position_last < 90)
		delta =  tuning_position_last + 360 - position_now;
	else
		delta = position_now - tuning_position_last;

	tuning_position_last = position_now;
	
	//reduce the precision of delta
	delta = Math.round(delta / knob_resolution);
	//tuning up or down by the step value		
	var step_text = el("STEP").value;
	var step_size = 1000;
	switch(step_text){
		case "10H": step_size = 10; break;
		case "100H": step_size = 100; break;
		case "1K": step_size = 1000; break;
		case "10K": step_size = 10000; break;
		case "100K": step_size = 100000; break;
	}
	f = el('FREQ');
	var freq = parseInt(f.value);
	freq = Math.round(freq/step_size) * step_size;
	if (delta > 0)
		delta = step_size;
	else
		delta = -step_size;
	f.value = freq + delta;
	update_freq(f.value);	
}

//initialization code

//link the knob to the jquery code
$(function($) {
	$(".knob").knob({
  	change : function (value) {
		tuning_knob_handler(value);
	},
	release : function (value) {
  	//console.log(this.$.attr('value'));
    //console.log("release : " + value);
 	},
	cancel : function () {
		//console.log("cancel : ", this);
	},
  draw : function () {
  }
  });
});



/* waterfall and spectrum */

function resize_ui(){
	var b = $("body");
	var sidebar_width = $("#sidebar").width();
	if ($("#sidebar")[0].style.display == "none")
		sidebar_width = 0;
	
	log("resize_ui w = " + b.width() + " h = " + b.height());

	el("waterfall").width = b.width()-sidebar_width;//-sidebar.width;
	el("spectrum").width = b.width()-sidebar_width;//-sidebar.width;
	$(".sbitx-panel").width = b.width()-sidebar_width;
	el("CW_ui").width = b.width()-sidebar_width;//-sidebar.width;
/*	if(b.height() > 600){
		el("waterfall").height = b.height() / 4;
		el("spectrum").height = b.height() /4;
	}*/
	height = b.height();
}

var waterfall_image = null;

function waterfall_init(){
	var w = el("waterfall");
	var ctx = w.getContext("2d");
	var waterfall_image = ctx.createImageData(w.width,w.height);
	i = 0;
	for (var y = 0; y < w.height; y++){
		for (var x = 0; x < w.width; x++){
			waterfall_image.data[i++] = (256 * y)/ w.height;
			waterfall_image.data[i++] = (256 * x)/ w.width;
			waterfall_image.data[i++] = 0;
			waterfall_image.data[i++] = 255;
		}
	}
	ctx.putImageData(waterfall_image, 0, 0);
}

var nbins = 0;

function spectrum_update(update){
	var w = el("spectrum");
	var ctx = w.getContext("2d");
	nbins = update.length - 3; //the first three characters are the  status
 	var scale = w.width/nbins;
	var height = w.height - 15;
	ctx.fillStyle = "#000";
	ctx.fillRect(0,0,w.width, w.height);

	//draw the filter block
	var low = el("LOW").value;
	var high = el("HIGH").value;
	var mode = el("MODE").value;
	var status = el("STATUS").value;
	var calculated_span = nbins * 46.875; //this comes from the sampling rate of the sdr
	var hz_per_pixel = w.width / calculated_span;
	
	ctx.fillStyle = "#444";
	if (mode == 'LSB' || mode == 'CWR'){
		ctx.fillRect(w.width/2 - (hz_per_pixel * high), 0, 
			(high-low) * hz_per_pixel, height);
	}
	else { 
		ctx.fillRect(w.width/2 + (hz_per_pixel * low), 0, 
			(high-low) * hz_per_pixel, height);
	}

	//draw the grid
	ctx.beginPath();
	for (var x = 0; x < 10; x++){
		ctx.moveTo(w.width*x/10, 0);
		ctx.lineTo(w.width*x/10, height);
	}
	for (var x = 0; x < 8; x++){
		ctx.moveTo(0, height*x/8);
		ctx.lineTo(w.width, x* height/8);
	}
	ctx.closePath();
	ctx.strokeStyle = "#333";
	ctx.stroke();

	//plot the spectrum
	ctx.beginPath();
	ctx.moveTo(w.width, height - (update.charCodeAt(0) - 32));
	//we index the charcodes at an offset of 3 (the first three are status)
	for (let x = 0; x < nbins; x++)
		ctx.lineTo((nbins - x - 1) * scale, height - (((update.charCodeAt(x+3) - 32)/100)*height));
	ctx.strokeStyle = "#ffff00";
	ctx.stroke();	
	
	//write the spectrum edges
	ctx.fillStyle="cyan";
	ctx.font = "14px Sans";
	ctx.fillStyle = "orange";

	//write the status
	ctx.fillText(status, w.width/2 - ctx.measureText(status).width/2, 14); 

	//show spots!
	let freq = parseInt(el("FREQ").value)/1000;
	let spot_count = 0;
	let spot_report = "";
	let dups = new Object();

	for (let i = 0; i < spots.length && spot_count < 10; i++){
		if (Math.abs(spots[i].frequency - freq) < 25){
			if (dups[spots[i].callsign] == undefined){
				spot_report = spot_report + " " + spots[i].frequency + "/" + spots[i].callsign + "/" + spots[i].mode;
				spot_count++;
				dups[spots[i].callsign] = spots[i].frequency;
			}
		}
	}
	ctx.font = "12px Sans";
	ctx.fillStyle = "white";
	ctx.fillText(spot_report, 0, height+12);

	//now, draw the tx and rx lines
	var rx_pitch = el("PITCH").value;
	var tx_pitch = el("TX_PITCH").value;

	ctx.beginPath();
	ctx.font = "12px Sans";
	ctx.strokeStyle = "cyan";
	ctx.fillStyle = "white";
	if (mode == 'CWR' || mode == 'LSB'){
		ctx.moveTo(w.width/2 - (rx_pitch * hz_per_pixel), 0);
		ctx.lineTo(w.width/2 - (rx_pitch * hz_per_pixel), height);
		ctx.fillText("RX", w.width/2 - (rx_pitch * hz_per_pixel)-10, height+12);
	}
	else{
		ctx.moveTo(w.width/2 + (rx_pitch * hz_per_pixel), 0);
		ctx.lineTo(w.width/2 + (rx_pitch * hz_per_pixel), height);
		ctx.fillText("RX", w.width/2 + (rx_pitch * hz_per_pixel)-10, height+12);
	}
	ctx.stroke();


	//draw the tx line separately only for FT8 
	if (mode != "FT8")
		return;

	ctx.beginPath();
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	if (mode == 'CWR' || mode == 'LSB'){
		ctx.moveTo(w.width/2 - (tx_pitch * hz_per_pixel), 0);
		ctx.lineTo(w.width/2 - (tx_pitch * hz_per_pixel), height);
		ctx.fillText("TX", w.width/2 - (tx_pitch * hz_per_pixel)-10, height+12);
	}
	else{
		ctx.moveTo(w.width/2 + (tx_pitch * hz_per_pixel), 0);
		ctx.lineTo(w.width/2 + (tx_pitch * hz_per_pixel), height);
		ctx.fillText("TX", w.width/2 + (tx_pitch * hz_per_pixel)-10, height+12);
	}
	ctx.stroke();
}

function waterfall_update(update){
	var w = el("waterfall");
	var i = 0;

	if (w.width == 0 || w.height== 0)
		return;

	nbins = update.length - 3;
	var scale = nbins/w.width;

	//get the tx and rx lines
	var rx_pitch = el("PITCH").value;
	var tx_pitch = el("TX_PITCH").value;
	var mode = el("MODE").value;
	var calculated_span = nbins * 46.875; //this comes from the sampling rate of the sdr
	var hz_per_pixel = w.width / calculated_span;
	var repeat = 3;

	if (mode == 'FT8')
		repeat = 1;
	else if (mode == 'CW' || mode == 'CWR')
		repeat = 2;
	

	var rx_spot = -1;
	var tx_spot = -1;

	if (mode == 'CWR' || mode == 'LSB')
		rx_spot = w.width/2 - (rx_pitch * hz_per_pixel);
	else
		rx_spot = w.width/2 + (rx_pitch * hz_per_pixel);
	rx_spot = Math.round(rx_spot);

	if (mode == 'FT8'){
		tx_spot = w.width/2 + (tx_pitch * hz_per_pixel);
		tx_spot = Math.round(tx_spot);
	}

	var ctx = w.getContext("2d", {willReadFrequently:true});

	//first move the old image down by 1 pixels (bitblt it down)
	var img = ctx.getImageData(0,0,w.width, w.height);
	ctx.putImageData(img, 0, repeat);

	//create a new strip of waterfall width, but 1 pixels high
	img = ctx.getImageData(0,0,w.width, 1);
	var i = 0;

	for (var x = 0; x < w.width; x++){
		var bin = (w.width - x) * scale;
		
		//the first three are status	
		var v = (update.charCodeAt(bin+3) - 32) * 2;
		if (v > 100)
			v = 100;
		var r, g, b;
		if (v < 20){
			r = 0;
			g = 0;
			b = v * 12;
		}
		else if (v < 40){
			r = 0;
			g = (v - 20) * 12;
			b = 255;
		}
		else if (v < 60){
			r =  0;
			g = 255;
			b = (60-v) * 12;
		}
		else if (v < 80){
			r = (v-60) * 12;
			g = 255;
			b = 0;
		} 
		else {
			r = 255;
			g = (100-v) * 12;
			b = 0;
		}
		if (x == tx_spot)
			img.data[i++] = 255;
		else 
			img.data[i++] = r;

		if (x == rx_spot){
			img.data[i++] = 255; 
			img.data[i++] = 255; 
		}
		else{	
			img.data[i++] = g;
			img.data[i++] = b; 
		}
		img.data[i++] = 255;	
	}

	for (i = 0; i < repeat; i++)
		ctx.putImageData(img, 0,i);
}

/* on screen keyboard panel */

var text_focus = null;

function sbitx_text_focus(event){
	text_focus = event.currentTarget;
}

function sbitx_onscreen_key(event){
	event.stopImmediatePropagation();
	var key = event.currentTarget.innerHTML;

	if (text_focus == null)
		return;

	//translate keys
	if (key == 'SPACE')
		key = ' ';
	else if (key == 'CMD')
		key = '\\';
	else if (key == 'Enter')
		key = '\n';

	//sent key strokes to be transmitted
	//even if the focus is not on datawindow
	//as long as we have the CW_ui opened

	if (text_focus.id == "data_window" ||
		(el("CW_ui").style.display == "block" && text_focus == null)){
		if (key == '\u21E4')
			websocket_send("key " + String.fromCharCode(8));
		else if (key == '\u23D8')
			websocket_send("key  ");
		else if (key == '\u2716')
			$("#keybd").hide();
		else if (key == "AR")
			websocket_send("key [");
		else if (key == "AS")
			websocket_send("key ]");
		else if (key == "BT")
			websocket_send("key &");
		else
			websocket_send("key " + key);
 		return;	
	}
	
	var caret = text_focus.selectionStart;
	var string = text_focus.value;

	//backspace
	if (key == '\u21E4' || key == 'DEL'){
		text_focus.value = string.substring(0,caret-1) + string.substring(caret);
		move_caret(text_focus, caret-1);
	}//enter key when the focus is on text_in
	else if ((key == "\u8617" || key == '\n') && text_focus.id == "text_in"){
		websocket_send(text_focus.value);
		text_focus.value = "";
	}
	else if (key == '\u23D8'){
		text_focus.value = string.substring(0, caret) + ' ' + string.substring(caret);
		move_caret(text_focus, caret+1);
	}
	else if (key == '[x]'){
		$("#keybd").hide();
	}
	else {
		if (key == '\u21A9')
			key = '\n';
		text_focus.value = string.substring(0, caret) + key + string.substring(caret);
		move_caret(text_focus, caret+1);
	}
}

function show_keyboard(){
	$("#keybd").show();
}
/* Filter Panel */

function receiver_panel_open(){
	log("intializing the receiver panel");
	//resize the waterfall and the spectrum, both need to be visible when tuning
	var waterfall = el("waterfall");
	var spectrum = el("spectrum");
//	spectrum.height = 50;
//	waterfall.height = 50;
		
}

function filter_set(event){
	var id =parseInt(event.currentTarget.id);
	var center = parseInt(el("PITCH").value);
	var mode = el("MODE").value;
	var low = 300;
	var high = 3000;

	websocket_send("bandwidth " + id);
}

/* audio stuff (this needs to work with webrtc data packets rather than websockets */
//setup the audio
var player = null;

function audio_start(){
	player = new PCMPlayer({
		encoding: '16bitInt',
		channels: 1,
		sampleRate: 48000,
		flushingTime: 200
   });
}

function move_caret(elem, caretPos) {

    if(elem != null) {
        if(elem.createTextRange) {
            var range = elem.createTextRange();
            range.move('character', caretPos);
            range.select();
        }
        else {
            if(elem.selectionStart) {
                elem.focus();
                elem.setSelectionRange(caretPos, caretPos);
            }
            else
                elem.focus();
        }
    }
}

//user interaction handlers

function open_panel(panel){
//	$(".sbitx-panel").hide();
	var active_panel = $("#"+panel);
	if (active_panel == undefined)
		return;
	$("#"+panel).show();
	if (window[panel+"_open"] == undefined)
		return;
	window[panel + "_open"]();
}

function close_panel(event){
	//extract the panel name from the parent
	var panel = event.currentTarget.parentElement;
	panel.style.display = "none";
	draw_dial(); //fwiw
	if (window[panel.id +"_close"] == undefined)
		return;
	window[panel.id +  "_close"]();
}

function sbitx_button_clicked(event){
	websocket_send(event.currentTarget.id);
}


function sbitx_selection_changed(event){
	var e = event.currentTarget;
	var id_reading = e.id + "_reading";
	websocket_send(e.id + " " + e.value);
	draw_dial(); 
}

function sbitx_slider_update(e){
	var id_reading = e.id + "_reading";
	if (el(id_reading)){
		if (el(id_reading).innerHTML != e.value)
			el(id_reading).innerHTML= e.value; 
	}
	draw_dial();
}

function sbitx_text_changed(event){
	var e = event.currentTarget;
			
	websocket_send(e.id + " " + e.value);
}

function sbitx_slider_changed(event){
	var e = event.currentTarget;
	if (e.id == "HIGH"){
		var low = el("LOW");
		if (parseInt(low.value) > parseInt(e.value)+200){
			if (parseInt(e.value) > 400)
				low.value = parseInt(e.value) - 200;
			else
				low.value = e.value;
			websocket_send("LOW " + low.value);
		}
	}
	if (e.id == "LOW"){
		var high = el("HIGH");
		if (parseInt(high.value) < parseInt(e.value)){
			if (parseInt(e.value) < 3800)
				high.value = parseInt(e.value) + 200;
			else
				high.value = e.value; 
			websocket_send("HIGH" + high.value);
		}
	}
			
	websocket_send(e.id + " " + e.value);
	sbitx_slider_update(e);
}

function sbitx_toggle_clicked(e){

	var btn = event.currentTarget;
	if (!btn.classList.contains('sbitx-toggle'))
		return;
	var cmd = btn.id.substring('toggle_'.length);
	if (el(cmd).value == "OFF")
		websocket_send(cmd +  " ON");
	else
		websocket_send(cmd +  " OFF");
}

function sbitx_toggle_update(e){

	var element = el('toggle_' + e.id);
	if(element == null)
		return;
	if (element.type == 'checkbox'){
		if (e.value  == "ON")
			element.checked = true;
		else
			element.checked = false;
	}
	else {
		if (e.value == 'ON'){
			element.innerHTML = e.id + " ON";
			element.style.backgroundColor = "yellow";
			element.style.color = "black";
		}
		else{
			element.innerHTML = e.id + " OFF";
			element.style.backgroundColor = "#555";
			element.style.color = "white";
		}
	}
	log("toggle updated");
	draw_dial();
}

function sbitx_list_select(event){
	var message = event.currentTarget.innerHTML;	
	
	event.currentTarget.classList.add("wsjtx-selected-message");
	log(message);
}



function switch_to_tx(){
	log("setting in_tx true");
	$("#tx_meters").show();
	in_tx = true;
}

function switch_to_rx(){
	$("#tx_meters").hide();
	log("setting in_tx false");
	in_tx = false;
}

/* wsjtx functionality */

var ft8_tx_count = 0;
var ft8_tx_on_even = true;
var ft8_tx_message = "";

function FT8_stylize_message(text, style){
	//tokenize the message
	var token_list = text.match(/\S+/g);
	if (token_list.length < 8 || token_list[4] != '~' || token_list.length > 9){
		log("FT8_process_message: error parsing [" + text + "]");
		return;
	}

	var index = 1;
	var confidence_score = token_list[1];
	var signal_strength = token_list[2];
	var rx_frequency = token_list[3];
	var contact_callsign = token_list[5]; 
	var sender_callsign = token_list[6]; 
	var message = token_list[7];
	var mycallsign = $("#MYCALLSIGN").val().toUpperCase();
	var mygrid = $("#MYGRID").val().substring(0,4).toUpperCase();

	if(style == 'Q')
		return "sbitx-list-item wsjtx-message-queued";
	if (contact_callsign == mycallsign)
		return "sbitx-list-item wsjtx-message-for-me";
	else if (sender_callsign == mycallsign)
		return "sbitx-list-item wsjtx-mycallsign";
	else if (sender_callsign == "CQ")
		return "sbitx-list-item wsjtx-cq-in-message";
	else 
		return "sbitx-list-item";
}

function FT8_list_append(list_id, text, style){

	var label_position = text.search("~");
	var label = text.substring(0,label_position);
	if (label.length == 21)
		label = label + '  ';
	var message = text.substring(label_position+1);
	var item = document.createElement("li");
	item.innerHTML = '<span class="ft8-label">' + label 
		+ '</span><span class="ft8-message">' + message + '</span>';
	item.className =  FT8_stylize_message(text, style);
	item.id = text;
	item.addEventListener("click", FT8_message_chosen);
	el(list_id).children[0].appendChild(item);
	item.scrollIntoView({behaviour: 'smooth', block:'nearest', inline:'start'});
}

function FT8_transmit(message){
	websocket_send("key " +  message + "\n");
	log("FT8 tx: " + message);
//	FT8_list_append("wsjtx-rx", message);
}

function FT8_cq(event){
	logger_wipe();
	logger_abort();
	var cq_type = el("ft8_cq_kindof").value;
	FT8_transmit(cq_type + " "  + el("MYCALLSIGN").value.toUpperCase() 
			+ " " + el("MYGRID").value.substring(0,4).toUpperCase());
}

//you can choose messages that are:
// 1. reply to your cq
// 2. someone calling cq
// 3. a message of your own that you want to resend

function FT8_message_chosen(event){
	var message_text = event.currentTarget.id;
	var mycallsign = $("#MYCALLSIGN").val().toUpperCase();

	if (message_text.length == 0)
		return;
	//tokenize the message
	var token_list = message_text.match(/\S+/g);
	if (token_list.length < 7 || token_list[4] != '~' || token_list.length > 9){
		log("FT8_process_message: error parsing [" + text + "]");
		return;
	}

	var index = 1;
	var confidence_score = token_list[1];
	var signal_strength = token_list[2];
	var rx_frequency = token_list[3];
	var mycallsign = $("#MYCALLSIGN").val().toUpperCase();

	var contact_callsign = "";
	var sender_callsign = ""
	//a message that I sent out, retransmit this
	if (token_list[6] == mycallsign){ 
		contact_callsign = token_list[5];
		FT8_transmit(message_text);
		return;
	}

	//this is the start of a new call
	logger_wipe();
	logger_abort();
	FT8_list_append("wsjtx-rx", message_text);
	websocket_send("FT8 "+message_text);
}

function FT8_new_message(text, style){
	log("ft8:" + text + ":" + style);
	var words = text.split(' ');
	FT8_list_append("wsjtx-activity", text, style) ;
	var mycallsign = $("#MYCALLSIGN").val().toUpperCase();
	if (words[4] == $("#FT8-rx-freq").val() || text.search(mycallsign) >= 0)
		FT8_list_append("wsjtx-rx", text, style);
}

// setup the html for wsjtx 
function FT8_open(){
	el("FT8_ui").style.display = "block";
}

/* cw functionality */

function cw_open(mode){
	if (document.location.hostname == "127.0.0.1")
		el("keybd").style.display = "block";
	text_focus = el("data_window");
	if (mode == 'RTTY' || mode == 'PSK31'){
		$("#data_chat").show();
		$("#cw_settings").hide();
	}
	else {
		$("#data_chat").hide();
		$("#cw_settings").show();
	}
	var b = $("body");
	if(b.height() > 600)
		el("data_window").styleheight = 50;
}

//the keystrokes, as they transfer to the sdr backend
//are color coded into different colored spans

function cw_keydown(c){
	//we changed this from being an evernt handler
	//var c = event.key; 
	
	if(el("MODE").value != "CW" && el("MODE").value == "CWR" &&
			el("MODE").value != "PSK31" && el("MODE").value != "RTTY")	
	return;
	
	if (c == "Shift" || c == "Alt"){
		logger_abort();
		return;
	}	
	else if (c == 'Escape'){
		logger_abort();
		return;
	}
	else if (c == 'Backspace')
		c = String.fromCharCode(8);
	else if (c.length > 1)
		return;

	log("user typed cw letter [" + event.key + "], sending to sdr");
	websocket_send("key " + c);
}

function cw_input_focus(event){
	text_focus = event.currentTarget;
}

function cw_update(text, kindof){
	var rx_window = el("data_window");
	var text_done = el("text_done");
	text_done.innerHTML = text_done.innerHTML
		+ '<span class="' + kindof + '">' + text + "</span>";
	rx_window.scrollTop = rx_window.scrollHeight;	
}

function data_tx(event){
	websocket_send("t ");
	text_focus = el("data_window");
}

function data_rx(event){
	websocket_send("r ");
	el("data_window").focus;
}

/* console functionality */

function console_update(text){
	var window = el("console_window");
	window.innerHTML = window.innerHTML + text;
	window.scrollTop = window.scrollHeight;	
}

function show_console_panel(){
	open_panel("console_panel");
}

/* telnet functionality */

function telnet_update(text){
	var window = el("telnet_window");
	window.innerHTML = window.innerHTML + text;
	window.scrollTop = window.scrollHeight;	
	
	let word = text.split(' ');
	let i = 0;
	if (word[i] != 'DX')
		return;
	i++;
	while(word[i] == '') i++;

	if (word[i] != 'de')
		return;

	i++;
	while(word[i] == '') i++;

	i++; //skip the spotter's callsign
	while(word[i] == '') i++;

	let freq = parseInt(word[i++]);

	while(word[i] == '') i++;

	let call = word[i++];	
	while(word[i] == '') i++;
	
	let m = word[i];	
	
	let s = {
		frequency: freq,
		callsign: call,
		mode: m,	
	}
	spots.unshift(s);
}

function show_telnet_panel(){
	open_panel("telnet_panel");
}

/* voice functionality */
function voice_open(){
//	el("spectrum").height =  150;
//	el("waterfall").height = 150;
}

function ptt_tx(event){
		websocket_send("t ");
}

function ptt_rx(event){
	websocket_send("r ");
}

/* logger functionality */


function logger_wipe(event){
	websocket_send("ABORT");
	$("CALL").val("");
	$("SENT").val("");
	$("RECV").val("");
	$("EXCH").val(""); 
	$("NR").val("");
}

function logger_abort(event){
	websocket_send("abort=1");
}

function logger_qrz(event){
	if($("#CALL").val().length < 2)
		return;

	var url = "https://www.qrz.com/db/" + $("#CALL").val();
	if (qrz_window == null)
		qrz_window = window.open(url, "_blank");
	else if (qrz_window.closed)
		qrz_window = window.open(url, "_blank");
	else
		qrz.window.location = url;
}

function logbook_open(event){
//	var url = "https://www.qrz.com/db/" + $("#CALL").val();
	var url = window.location.href+ "logbook.html";

	if (qrz_window == null)
		qrz_window = window.open(url, "_blank");
	else if (qrz_window.closed)
		qrz_window = window.open(url, "_blank");
	else
		qrz.window.location = url;
}
function logger_enter_qso(){
	var contact_callsign = el("CALL").value.toUpperCase();
	var rst_sent = el("SENT").value.toUpperCase();
	var exchange_sent = el("NR").value.toUpperCase();
	var rst_recv = el("RECV").value.toUpperCase();	
	var	exchange_recv = el("EXCH").value.toUpperCase();	
	if (contact_callsign.length < 2 || !rst_sent.length  || !rst_recv.length){
		alert("Fill the logger callsign, RST sent, received to save the QSO");
		return;
	}
	websocket_send("qso="+ contact_callsign +"|"+rst_sent+"|"+ exchange_sent 
		+ "|" + rst_recv + "|" + exchange_recv); 
	logger_wipe();
	setTimeout(logbook_reload, 500);
}

function logger_trigger_macro(event){
	websocket_send(event.id);
}

function logger_bind_key(fn_key, macro_line){
	//extract the key name
	var key_name = "";
	var i;
	for (i =0; i < macro_line.length; i++)
		if (macro_line.charAt(i) == ',')
			break;
	if (i == 0 || i == macro_line.length)
		return;
	if (fn_key){
		var e = el(fn_key);
		if (e != null){
			el(fn_key).innerHTML = e.id + "<br>" + macro_line.substring(0, i);
			el(fn_key).dataset.macro_text = macro_line.substring(i+1);
		}
	}
}

//we expect the macro file to be in n1mm format
function logger_keys_update(){
	var lines = macros_file.split("\n");
	for (var i = 0; i < lines.length; i++){
		var line = lines[i];
		//we deal only with the lines that start with 'FN ' or 'FNN '
		if (line.charAt(0) == 'F' && isdigit(line.charAt(1))){
			if (isdigit(line.charAt(2)) && line.charAt(3) == ' ')
				logger_bind_key(line.substring(0,3), line.substring(4));
			else if (line.charAt(2) == ' ')
				logger_bind_key(line.substring(0,2), line.substring(3));
		}
	}
}

function logger_set_macro(macro_file_name){
	if(el("MACRO").value != macro_file_name)
		el("MACRO").value = macro_file_name;
	jQuery.get("/"+macro_file_name+".mc", function(data){macros_file = data; logger_keys_update();});
}

function logger_get_macro_file(event){
	var macro_file_name = event.currentTarget.value;
	logger_set_macro(macro_file_name);
}

function logger_toggle_macros(event){
	if ( el("logger-macros").style.display == "block"){
		el("logger-macros").style.display = "none";
		return;
	}
	el("logger-macros").style.display = "block";
	var macro_file_name = el("MACROS_list").value
	jQuery.get("/"+macro_file_name+".mc", function(data){macros_file = data; logger_keys_update();});
}

function logger_list_macros(list){
	var names = list.split("|");
	var sel = el("MACRO");
	sel.innerHTML = "";
	for (var i = 0; i < names.length; i++)
		if (names[i].length > 0)
			sel.appendChild(new Option(names[i], names[i]));
}

// trigged when the back sdr changes the macros
function logger_macro_changed_from_sdr(new_macro){
	if (el("MACRO").value == new_macro)
		return;
	el("MACRO").value = new_macro;
	websocket_send("macro_labels=" + new_macro);
}

/* logbook 
web api:
	logbook=0 loads the last 50 qsos
	any +ve number loads 50 qsos with earlier
*/

function logbook_update(args){
	var token = args.split("|");
	var insert_index = 0; //at the top
	if(token.length < 10)
		return;

	var qso_id = token[0];

	if (logbook_top_row_id < Number(qso_id))
		logbook_top_row_id = Number(qso_id);
	if (logbook_bottom_row_id > Number(qso_id)){
		logbook_bottom_row_id = Number(qso_id);
		insert_index = -1; //insert at the bottom
	}

	var table = $("#logbook_table tbody")[0];

	//replace existing row?
	var row = el("logentry-"+token[0]);
	if (row == null){
		row = table.insertRow(insert_index);
		row.id = "logentry-" + token[0];
	} else {
		for (var i = 0; i < 8; i++)
			row.deleteCell(-1);
	}

	//date and time are at position 3, 4
	item = row.insertCell(-1);
	item.innerHTML = qso_id;
	item.className = "logbook-field logbook-serial";

	item = row.insertCell(-1);
	item.innerHTML = token[3] + ' ' + token[4];
	item.className = "logbook-field logbook-datestamp";
	//frequency
	item = row.insertCell(-1);
	item.innerHTML =  token[2];
	item.className = "logbook-field logbook-freq";
	//mode
	item = row.insertCell(-1);
	item.innerHTML = token[1];
	item.className = "logbook-field logbook-mode";
	//callsign
	item = row.insertCell(-1);
	item.innerHTML = token[8];
	item.className = "logbook-field logbook-call";
	//sent
	item = row.insertCell(-1);
	item.innerHTML = token[6] + '  ' + token[7];		
	item.className = "logbook-field logbook-sent";
	//received
	item = row.insertCell(-1);
	item.innerHTML = token[9] + '  ' + token[10];		
	item.className = "logbook-field logbook-recv";
}

function logbook_reset(){
	$("#logbook_table tbody")[0].innerHTML = "";
 	logbook_bottom_row_id = 10000000;
 	logbook_top_row_id = 0;
}

function open_logbook(event){
	open_panel("logbook_panel");
}

function close_logbook(event){

}
//ask for qso made after a particular qso id
//or qso made prior to a particular qso_id (prior is minus)
function logbook_request(qso_id){
	var q = "logbook="+Number(qso_id);
	if (el("logbook-search").value.length > 0)
		q += " " + el("logbook-search").value.toUpperCase();
	websocket_send(q);
}

function logbook_more(){
	logbook_request(logbook_bottom_row_id);
}

function logbook_search(){
	logbook_reset();
}

function open_logbook(event){
	open_panel("logbook_panel");
}


/* settings panel */

function open_settings(){
	open_panel("settings_panel");
	//set the focs to the pin
	el("PASSKEY").focus();
}

function save_settings(){
	websocket_send("MYCALLSIGN " + el("MYCALLSIGN").value);
	websocket_send("MYGRID " + el("MYGRID").value);
	websocket_send("PASSKEY " + el("PASSKEY").value);
	websocket_send("SIDETONE " + el("SIDETONE").value);
	websocket_send("TELNETURL " + el("TELNETURL").value);
	$("#settings_panel").hide();
}

/* recorder panel */

var record_started = -1;

function open_recorder(){
	open_panel("recorder_panel");
}

function start_recorder(){
	websocket_send("REC ON");
}

function stop_recorder(){
	websocket_send("REC OFF");
	el("recorder_panel").style.display = "";
}

function update_recorder(){
	if (record_started == -1)
		el("record_duration").innerHTML = "00:00";
	else {
		seconds = Math.round(Date.now()/1000) - record_started;
		minutes = Math.round(seconds / 60);
		seconds = Math.round(seconds % 60);
		el("record_duration").innerHTML = ("0" + minutes).slice(-2) 
			+ ":" + ("0" + seconds).slice(-2);
	}
}

/* switching the ui for different modes */

// response from the sdr 

function update_data(text){
	var xml = parser.parseFromString("<updates>" + text + "</updates>", "text/xml");
	if (xml != null){
		var wsjtx = xml.getElementsByTagName("WSJTX-RX");
		if (wsjtx)
			for (var i = 0; i < wsjtx.length; i++)
				if (wsjtx[i].innerHTML.length > 30)
					FT8_new_message(wsjtx[i].innerHTML, "RX");

		//read the QSO specific ones too
		wsjtx = xml.getElementsByTagName("WSJTX-TX");
		if (wsjtx)
			for (var i = 0; i < wsjtx.length; i++)
				if (wsjtx[i].innerHTML.length > 30)
					FT8_new_message(wsjtx[i].innerHTML, "TX");

		//read tx message in the Q 
		wsjtx = xml.getElementsByTagName("WSJTX-Q");
		if (wsjtx)
			for (var i = 0; i < wsjtx.length; i++)
				if (wsjtx[i].innerHTML.length > 30)
					FT8_new_message(wsjtx[i].innerHTML, "Q");

		var data = xml.getElementsByTagName("TELNET");
		if (data && in_tx == false)
			for (var i = 0; i < data.length; i++)
				telnet_update(data[i].innerHTML, "telnet");

		var data = xml.getElementsByTagName("FLDIGI-RX");
		if (data && in_tx == false)
			for (var i = 0; i < data.length; i++)
				cw_update(data[i].innerHTML, "data_rx");

		var data = xml.getElementsByTagName("FLDIGI-TX");
		if (data && in_tx == true)
			for (var i = 0; i < data.length; i++)
				cw_update(data[i].innerHTML, "data_tx");

		var data = xml.getElementsByTagName("CW-TX");
		if (data)
			for (var i = 0; i < data.length; i++)
				cw_update(data[i].innerHTML, "data_tx");

		var data = xml.getElementsByTagName("CW-RX");
		if (data)
			for (var i = 0; i < data.length; i++)
				cw_update(data[i].innerHTML, "data_rx");

		var data = xml.getElementsByTagName("LOG");
		for (var i = 0; i < data.length; i++)
				write_console(data[i].innerHTML);
	}
	else
		console_update(text);
//		el("log").insertAdjacentHTML("beforeend", text);
}

var ticks = 0;
function ui_tick(){
	if (socket == null)
		return;

	//recorder update if it is running
	if(record_started != -1)
		update_recorder();

	if (socket.readyState != 1)
		return;
	if (session_id ==  'nullsession')
		return;
	if (player != null)
		websocket_send("audio");
	else
		websocket_send("spectrum");

	ticks++;
	if (ticks % 10 == 0)
		logbook_request(-logbook_top_row_id);
}

function mode_set(new_mode){

	var wf = el("waterfall");
	var sp = el("spectrum");
	wf.height = 100;
	sp.height = 100;

	$(".mode-panel").hide();
	switch(new_mode){
		case 'CW':
		case 'CWR':
			wf.height=150;
			sp.height = 100;
			cw_open(new_mode);
			$("#CW_ui").show();
			logger_set_macro("CW1");
		break;
		case "LSB":
		case "USB":
		case "2TONE":
			wf.height=150;
			sp.height = 100;
			$("#Voice_ui").show();
			logger_set_macro("CW1");
			break;
		case 'FT8':
			sp.height = 50;
			wf.height=50;
			FT8_open();
			$("#FT8_ui").show();
			logger_set_macro("FT8");
			break;
		default:
			wf.height=150;
			var panel_name = "#" + new_mode + "_ui";
			var active_panel = $(panel_name);
			logger_set_macro("CW1");
			if (active_panel.length > 0)
				$(panel_name).show();
					return;
	}
//	if (window[new_mode+"_open"] == undefined)
//		return;
//	window[new_mode + "_open"]();
}

function mode_changed(event){
	mode_set(event.currentTarget.value);
}

//audio interpolation variables
var prev_sample = 0;
var intp_factor = 3;
function response_handler(response){
	var cmd = "";
	var args = "";

	if (response instanceof Blob){
		f = new FileReader();
		f.onload = () => {
			if (player != null){
				var samples = new Int16Array(f.result);
				var upsample =  new Int16Array(samples.length * intp_factor);
				var j = 0;	
				//interpolate, generating higher sampling rate
				for (var i = 0; i < samples.length; i++)
					for (var x = 0; x < intp_factor; x++){
						upsample[j++] = ((prev_sample * (intp_factor- x- 1)) 
							+ (samples[i] * (x + 1)))/intp_factor; 
						prev_sample = samples[i];
					}
				player.feed(upsample);
			}
		}
		f.readAsArrayBuffer(response);
		return;
	}

	if (response.substring(0,3) == "TX " || response.substring(0,3) == "RX "){

		if (response.substring(0,2) == "TX" && in_tx == false)
			switch_to_tx();
		else if (response.substring(0,2) == "RX" && in_tx == true)
			switch_to_rx();
	
		spectrum_update(response);
		if (in_tx == false)
			waterfall_update(response);
		return;
	}

	var i = response.indexOf(' ');	
	if (i >= 0){
		cmd = response.substring(0, i);
		args = response.substring(i+1);
	}
	else
		return;

	switch(cmd){
		case 'quit':
			log("Received a quit message");
			session_id = "nullsession";
			socket.close();
			end_login("Logged in from a another device");
			break;
		case 'login':
			if (args !=  'error'){
				session_id = args;
				document.cookie ="sessionid="+session_id+";path=/";
				log("session_id set to " + session_id);
				show_main();
				resize_ui();
			}
			else
				alert("Incorrect passkey.\r\nIf you have forgotten your pass key\r\n" +
				"You can see it in user_settings.ini in sbitx/data folder");
			break;
		case 'QSO':
			logbook_update(args);
			break;
		case 'TEXT':
			log("text: [ " + args + "]");
			el("text_pending").innerHTML = args;
			break;
		case 'CONSOLE':
			update_data(args);
			break;
		case 'SPECTRUM':
		case 'WATERFALL':
			break;
		case 'FREQ':
			e = el(cmd);
			log("freq " + args);
			if (e)
				e.value = args;
			//update the selected VFO
			if (el("VFO").value  == 'A')
				el("VFOA").value = args;
			else
				el("VFOB").value = args;
			draw_dial();
			break;
		case 'macros_list':
			logger_list_macros(args);
			break;
		case 'MACRO':
			logger_macro_changed_from_sdr(args);
			break;
		case 'MODE':
			mode_set(args); 
			//There is no break statement here, MODE continues to default case
		default:
			e = el(cmd);
			if (e){
				if (e.value != args){
					e.value = args;
//					log("changing from " + e.value + " to [" + args + "]");
					if (e.classList.contains('knob-value'))
						knob_update(e);
					else if (e.classList.contains("linear-value"))
						update_linear(e);
					else if(e.classList.contains('sbitx-update-toggle'))
						sbitx_toggle_update(e);
					else if (cmd == "MYCALLSIGN" && args== "NOBODY")
						open_settings("settings_panel");
					else if (cmd == 'SPLIT')
						draw_dial();
					if (cmd == "REC"){
						if (args == "ON")
							record_started  = Math.round(Date.now()/1000);
						else
							record_started = -1; 							
						update_recorder();
					}
				}

			}
		/*	else
				log("unhandled " + cmd + " : " + args);
		*/

			if (cmd == 'REF'){
				draw_meters();
//				log("meter : " + el("POWER").value + "," + el("REF").value);
			}
	}
}

parser = new DOMParser();
show_login();
waterfall_init();
setInterval(ui_tick, 50);
spots = [];

//init the event handlers
window.addEventListener("resize", resize_ui);
window.addEventListener("click", on_click);
$(".sbitx-btn").on("click", sbitx_button_clicked);
$(".sbitxv3-btn").on("click", sbitx_button_clicked);
//$(".sbitxv3-control").on("click", sbitxv3_control_clicked);
$(".sbitx-selection").on("change", sbitx_selection_changed);	
$(".sbitx-slider").on("input", sbitx_slider_changed);
$(".sbitx-toggle").on("click", sbitx_toggle_clicked);
$(".sbitx-keystroke td").on("click", sbitx_onscreen_key);
$(".sbitx-panel-title").on("click", close_panel);
$(".sbitx-text-field").on("change keydown paste input",sbitx_text_changed);
$(".linear-slider").on("input", on_linear_moved);
$(".linear").on("click",  linear_toggle);
$(".macro-btn").on("click", logger_trigger_macro);

//ft8 specific handlers
//$(".ft8-clickable").on("click", FT8_message_chosen);

//specific control handler
$("#REF").on("change", draw_meters);
$("#MODE").on("change", mode_changed);
$("#console-open").on("click", show_console_panel);
$("#telnet-open").on("click", show_telnet_panel);
$("#keyboard-open").on("click", show_keyboard);
$("#MACRO").on("change", logger_get_macro_file);
//vfo buttons
$("#vfo_reset").on("click", vfo_set);
$("#vfo_swap").on("click", vfo_set);

// logger buttons
$("#wipe").on("click", logger_wipe);
$("#esc").on("click", logger_abort);
$("#qrz").on("click", logger_qrz);
$("#logger-log").on("click", logger_enter_qso);
//$("#macros").on("click", logger_toggle_macros);
$("#MACRO").on("change", logger_get_macro_file);
$(".macro-button").on("click", logger_trigger_macro); 
//function key handlers
document.addEventListener('keydown', function(e){
	if(e.key.length > 1 && e.key[0] == 'F' && isdigit(e.key[1])){
		websocket_send(e.key);
		e.preventDefault();
	}
	else if (e.key == 'Escape'){
		websocket_send("ESC");
		e.preventDefault();
	}
	else if (e.key == "Enter" && text_focus != null && text_focus.id == "text_in"){
		websocket_send(text_focus.value);
		text_focus.value = "";
	}
	else if (e.key == "Enter" && text_focus != null && text_focus.id == "telnet_in"){
		websocket_send("tel " + text_focus.value);
		text_focus.value = "";
	}
	else if (text_focus.id == "data_window"){
			cw_keydown(e.key);
	}
});
	

$("#start_login").on("click", do_login);
//cw buttons, also used for chatty data
$("#data_window").on("click", cw_input_focus);
$("#data_chat_tx").on("click", data_tx);
$("#data_chat_rx").on("click", data_rx);
//$(".sbitxv3-slider").on("click", toggle_slider);
//ssb buttons
$("#ptt_tx").on("click", ptt_tx);
$("#ptt_rx").on("click", ptt_rx);

//logbook buttons
$("#logbook-open").on("click", logbook_open);
$("#btn-logbook-close").on("click", close_logbook);
$("#btn-logbook-search").on("click", logbook_request);
$("#btn-logbook-load").on("click", logbook_more);
$("#logbook-search").on("input", logbook_search);

//settings buttons
$("#settings-open").on("click", open_settings);
$("#settings_save").on("click", save_settings);

//recorder buttons
$("#recorder-open").on("click", open_recorder);
$("#record_start").on("click", start_recorder);
$("#record_stop").on("click", stop_recorder);

//toggle the soft dial knob
$("#dial").on("click", toggle_dial);
window.onload = ui_init();

//init the state of the ui
function ui_init(){
	$(".sbitx-text-input").on("focus", sbitx_text_focus);
	$("#tx_rx").hide();
	$(".sbitx-panel").hide();
	$("#extra-controls").hide(); //do something about these
	$("#more_keys").hide(); //do something about these
	logger_set_macro("CW1");
	logbook_reset();
	if (document.location.hostname == "127.0.0.1"){
//		window.addEventListener("contextmenu", function(e) { e.preventDefault(); }); //uncomment in production
//		$("#tuning_knob").hide();
	}
	if (document.location.hostname == "127.0.0.1"){
		show_keyboard();
		do_login();
	}
/*	else
		$("#keybd").hide();*/
}

function v3control_number(id, start, stop, step){
	var c = document.getElementById(id);
	for (var i = start; i <= stop; i += step){
		var option = document.createElement("option");
		option.text = i.toString();
		option.value = i.toString();
		option.className = "sbitxv3-option";
		c.add(option);
	}
}

function sbitxv3_control_clicked(event){
	//find the nested button or select, just one in the control
	var id = event.currentTarget.getElementsByTagName("select")[0].id;
	var	select_control = el(id);
	var options = select_control.options;
	if (options.selectedIndex < options.length - 1)
		select_control.value = options[options.selectedIndex+1].text;
	else
		select_control.value = options[0].text;
	
	websocket_send(id + " " + select_control.value); 
}


/* knob control handlers */

function linear_toggle(event){
	var drop_id = event.currentTarget.id.substring(7);
	var div_el = event.currentTarget.querySelector(".linear-dropdown");
	if (div_el.style.display == "block")
		div_el.style.display = "";
	else{
		div_el.style.display = "block";
		//send this value to the radio to get the focus here
		//this will enable the control encoder to work 
		websocket_send(drop_id+ " " + el(drop_id).value);
	}
}


//when the user changes the value
function on_linear_moved(event){
	var control = event.currentTarget;
	var control_id = control.id.substring(7);
	el(control_id).value = control.value;
	websocket_send(control_id + " " + control.value);
}

//called in update from the server
//the value is already set in the readonly control
//we just duplicate it on the slider
function update_linear(event){
	event.parentNode.querySelector(".linear-slider").value = event.value;
}

/* close any open linear controls if clicked outside*/
function on_click(event){
	log("clicked");
	var target = event.target;

	//don't close if the click is within the controls slider
	if(target.classList.contains("linear-slider") ||
		target.classList.contains("linear-dropdown") || 
		target.classList.contains("linear-value"))
		return;

	var collection = document.getElementsByClassName("linear-dropdown");
	for (var i = 0; i < collection.length; i++)
		collection[i].style.display = "";
}

function toggle_dial(event){
	var dial = el("sidebar");
	var main = el("main");
	if (dial.style.display == "block"){
		main.style.marginLeft = 0;
		dial.style.display = "none";	
	}
	else {
		main.style.marginLeft = 200;
		dial.style.display = "block";	
	}
	resize_ui();	
}

function write_console(str){
	var con = $("#console");
	con[0].innerHTML = str;
	con.fadeIn(0);
	con.fadeOut(6000);
}
</script>
</html>
